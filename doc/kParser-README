/* SPDX-License-Identifier: BSD-2-Clause-FreeBSD */
/* Copyright (c) 2022, SiPanda Inc.
 * Author:     Pratyush Kumar Khan <pratyush@sipanda.io>
 */

Introduction to kParser
-----------------------
kParser stands for "The Kernel Parser". This is a programmable network packet
parser which is a ported version of the PANDA parser.

For the introduction to the basic building blocks of PANDA parser, kindly refer
https://github.com/panda-net/panda/blob/main/documentation/parser.md

The iproute2 CLI for the kParser works in tandem with the KMOD kParser. Hence
the KMOD kParser must be loaded before the kParser enabled iproute2 CLI can be
used to configure and use it.

The kParser is hightly programmable, to add any types of network protocol packet
parsing support, there is no need to write or compile new code. kParser can be
configured to parse any networking protocol packet. Only the kParser CLI is
sufficient to configure and teach the KMOD kParser about how to parse any new
protocol and add that capability to Linux Kernel.

kParser objects/namespaces
--------------------------
Building blocks of kParser are various objects from different namespaces/object
types. Various namespaces will be in the next section.

Each object is identified by a maximum 128 bytes long '\0' terminated (128 bytes
including the '\0' character) human readable ASCII name (only character '/' is
not allowed in the name, and names can not start with '-'). Alternatively an
unsigned 16 bit ID or both ID and name can be used to identify objects.
NOTE: During CLI create operations of these objects, it is must to specify
either the name or ID. Both can also be specified.
Whichever is not specified during create will be auto generated by the KMOD
kParser and CLI will convey the identifiers to user for later use. User should
save these identifiers.
NOTE:
name and ID must always unqiue for any specific object type.
name or id can later be used to identify the associated object.

Various objects are:
	1. condexprs: "Conditional expressions" used to define and configure
		various complex conditional expressions in kParser.
		They are used to validate certain conditions for
		protocol packet field values.

	2. condexprslist: "List of Conditional expressions" used to create
		more complex and composite expressions involving more than one
		conditional expression(s).
			
	3: condexprstable: "A table of Conditional expressions" used to
		associate one or more than one list of Conditional expressions
		with a packet parsing action handlers, i.e. parse node.

	4: counter: It is used to create and configure counter objects which can
		be used for a wide range of usages such as count how many VLAN
		headers were parsed, how many TCP options are encountered etc.

	5: countertable: There is only a single global table of counters, the
		size of this table is 7. Multiple kParser parser instances can
		share this countertable.

	6: metadata-rule: Defines the metadata structures that will be passed to
		the kParser datapath parser API by the user. This basically
		defines a specific metadata extraction rule. This must match
		with the user passed metadata structure in the datapath API.

	7: metadata-ruleset: A list of metadata(s) to associate it with packet
		parsing action handlers, i.e. parse node.

	8: node: A node (a.k.a parse node) represents a specific protocol header.
		Defining protocol handler involves multiple work, i.e.configure
		the parser about the associated protocol's packet header, e.g.
		minimum header length, where to look for the next protocol field
		in the packet, etc.
		Along with that, it also defines the rules/handlers to parse and
		store the required metadata by associating a metalist.
		The table to find the next protocol node is attached to node.
		node can be 3 types: PLAIN, TLVS and FLAGFIELDS.
		PLAIN nodes are the basic protocol headers.
		TLVS nodes are the Type-Length-Value protocol headers, such as
		TCP. They also binds a tlvtable to a node.
		FLAGFIELDS are indexed flag and associated flag fields protocol
		headers, such as GRE headers. It also binds a flagstable with
		a node.

	9: table: A table is a protocol table, which associated a protocol
		number with a node. e.g. ethernet protocol type 0x8000 in
		network order means the next node after ethernet header is IPv4.

		NOTE: table has key, key must be unique. Usually this key is
		protocol number, such as ethernet type, or IPv4 protocol number
		etc.

	10: tlvnode: A tlvnode defines a specific TLV parsing rule, e.g. to
		parse TCP option MSS, a new tlvnode needs to be defined.
		Each tlvnode can also associate a metalist with the TLV parsing
		rule, i.e. tlvnode

	11: tlvtable: This is a table of multiple tlvnode(s) where the key are
		types of TLVs (e.g. tlvnode defined for TCP MSS should have the
		type/kind value set to 2.

	12: flags: It describes certain protocol's flags., e.g. GRE flags.

	13: flagfields: It defines flagfields for the above mentioned flags.
		e.g. GRE flagfields such as checksum, key, sequence number etc.

	14: flagstable: This defines a table of flagfields and associate them
		with their respective flag values via their indexes. Here the
		keys are usually indexes, because in typical flag based protocol
		header, such as GRE, the flagfields appear in protocol packet in
		the same order as the set flag bits. The flag is defined by the
		flag value, mask, size and associated metalist.

	13: parser: A parser represents a parse tree. It defines the user
		metadata and metametadata structure size, number of parsing node
		and encapsulation limits, root node for the parse tree, success
		and failure case exit nodes.

	14. parserlockunlock: This is to lock a parser and unlock it later when
		usage is done. During locked period, the whole parse tree
		becomes immutable and can not be modified/deleted until
		unlocked. This is needed to protect modify/delete during data
		path operations.

kParser KMOD datapath APIs
---------------------
Following 4 datapath APIs are exposed by KMOD kParser.

/* kParser datapath API 1: parse a skb using a parser instance key.
 * skb: input packet skb
 * kparser_key: key of the associated kParser parser object which must be
 *		already created via CLI.
 * _metadata: User provided metadata buffer. It must be same as configured 
 *	      metadata objects in CLI.
 * metadata_len: Total length of the user provided metadata buffer.
 * return: kParser error code as defined in include/uapi/linux/kparser.h
 */
int kparser_parse(
		struct sk_buff *skb,
		const struct kparser_hkey *kparser_key,
		void *_metadata,
		size_t metadata_len);

/* kParser datapath API 2: get/freeze a parser instance using a key.
 * kparser_key: key of the associated kParser parser object which must be
 * already created via CLI.
 * return: NULL if key not found, else an opaque parser instance pointer which
 *	   can be used in the following APIs 3 and 4.
 * NOTE: This call makes the whole parser tree immutable. If caller calls this
 * more than once, later caller will need to release the same parser exactly that
 * many times using the API kparser_put_parser().
 */
const void * kparser_get_parser(
		const struct kparser_hkey *kparser_key);

/* kParser datapath API 3: parse a void * packet buffer using a parser instance
			   key.
 * parser: Non NULL kparser_get_parser() returned and cached opaque pointer
 *	   referencing a valid parser instance.
 * _hdr: input packet buffer
 * parse_len: length of input packet buffer
 * _metadata: User provided metadata buffer. It must be same as configured 
 *	      metadata objects in CLI.
 * metadata_len: Total length of the user provided metadata buffer.
 * return: kParser error code as defined in include/uapi/linux/kparser.h
 */
int __kparser_parse(
		const void *parser,
		void *_hdr,
		size_t parse_len,
		void *_metadata,
		size_t metadata_len);

/* kParser datapath API 4: put/un-freeze a parser instance using a previously
 * obtained opaque parser pointer via API kparser_get_parser().
 * parser: Non NULL kparser_get_parser() returned and cached opaque pointer
 *	   referencing a valid parser instance.
 * return: true if put operation is success, else false.
 * NOTE: This call makes the whole parser tree deletable for the very last call.
 */
bool kparser_put_parser(const void *parser);
